---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 15장 요약"
description: 스마트 포인터
author: 김우석
date: 2025-10-13 19:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

- 포인터 : 메모리의 주솟값을 담고 있는 변수에 대한 일반적인 개념
- 스마트 포인터 : 포인터처럼 작동할 뿐 아니라 추가적인 메타데이터와 능력을 가지고 있는 데이터 구조

## Box<T>를 사용하여 힙에 있는 데이터 가리키기
- 스마트 포인터 박스(box)는 `Box<T>` 로 쓰이는 타입이며 **힙 메모리에 데이터를 저장**하고, 그 데이터를 가리키는 **포인터(Box) 자체는 스택(Stack) 에 저장**됨
- Box<T> 타입은 **Deref 트레이트를 구현**하고 있기 때문에 스마트 포인터이며, 이는 Box<T>값이 참조자와 같이 취급되도록 허용해줌
- 박스는 스코프를 벗어날 때 할당이 해제되며 할당 해제는 **스택에 저장된 박스**와 이것이 가리키고 있는 **힙에 저장된 데이터** 모두에게 일어나는데 이는 **Drop 트레이트의 구현** 때문

### Box<T>를 사용하여 힙에 데이터 저장하기
- `let b = Box::new(5);` 와 같이 사용할 수 있으며, 여기서 `5` 는 힙에 할당됨

### 박스로 재귀적 타입 가능하게 하기
- 재귀적 타입의 값은 자신 안에 동일한 타입의 또 다른 값을 담을 수 있지만, 러스트는 컴파일 타임에 어떤 타입이 얼마만큼의 공간을 차지하는지 알아야 하기 때문에 재귀적 타입은 문제를 일으킴
- 박스는 알려진 크기를 갖고 있으므로, 재귀적 타입의 정의에 박스를 집어넣어 재귀적 타입을 가능하게 함

## Deref 트레이트로 스마트 포인터를 보통의 참조자처럼 취급하기
- Deref 트레이트를 구현하면 **역참조 연산자(dereference operator) \*** 동작의 커스터마이징을 가능하게 해주며, 스마트 포인터가 보통의 참조자처럼 취급될 수 있도록 해줌
    - 역참조 연산이란, 어떠한 변수의 참조자에 *를 사용하여 참조자를 따라가서 이 참조자가 가리키고 있는 값을 얻어내는 것을 말함

### Deref 트레이트를 구현하여 임의의 타입을 참조자처럼 다루기
- Deref 트레이트는 deref 라는 이름의 메서드 하나를 구현하도록 요구하는데, 이 함수는 self 를 빌려와서 내부 데이터의 참조자를 반환함
- deref 메서드는 컴파일러가 Deref를 구현한 어떤 타입의 값에 대해 deref 메서드를 호출하여, **자신이 역참조하는 방법을 알고 있는 & 참조자를 가져올 수 있는 기능**을 제공 
    - 러스트는 * 연산자에 deref 메서드 호출과 보통의 역참조를 대입하므로 deref 메서드를 호출할 필요가 있는지 없는지에 대해 생각하지 않아도 됨 ( `*변수` 는 `*(변수.deref())` 와 같이 작동됨 )
- defer 메서드가 값의 참조자를 반환하고, `*(변수.deref())`에서 괄호 바깥의 일반 역참조가 여전히 필요한 이유는 소유권 시스템과 함께 작동시키기 위함 ( 만약 deref 메서드가 값의 참조자 대신 값을 직접 반환했다면, 그 값은 self 바깥으로 이동 할 것임 )

### 함수와 메서드를 이용한 암묵적 역참조 강제
- 역참조 강제는 Deref를 구현한 어떤 타입의 참조자를 다른 타입의 참조자로 바꿔줌
    - 예를들어, 역참조 강제는 &String 을 &str 로 바꿔줄 수 있는데, 이는 String의 Deref 트레이트 구현이 &str을 반환하도록 했기 때문
    - 어떤 특정한 타입값에 대한 참조자를 함수 혹은 메서드의 인수로 전달할 때, 이 함수나 메서드의 정의에는 그 매개변수 타입이 맞지 않을 때 자동으로 발생 (일련의 deref 메서드 호출이 인수로 제공한 타입을 매개변수로서 필요한 타입으로 변경해줌)
- 역참조 강제는 함수와 메서드 호출을 작성하는 프로그래머들이 &와 *를 사용하여 수많은 명시적인 참조 및 역참조를 추가할 필요가 없도록 하기 위해 도입됨
- 인수로 넣어진 타입에 대해 Defer 트레이트가 정의되어 있다면, 해당 타입을 분석하고 Deref::deref를 필요한 만큼 사용하여 매개변수 타입과 일치하는 참조자를 얻음 (`Deref::deref`가 추가되어야 하는 횟수는 컴파일 타임에 분석되므로, 역참조 강제의 이점을 얻는데에 관해서 어떠한 런타임 페널티도 없음)

### 역참조 강제가 가변성과 상호작용하는 법
- Deref 트레이트 : 불변 참조자에 대한 * 연산자를 오버라이딩
- DerefMut 트레이트 : 가변 참조자에 대한 * 연산자를 오버라이딩

## Drop 트레이트로 메모리 정리 코드 실행하기
- Drop 트레이트 : 어떤 값이 스코프 밖으로 벗어나려고 할 때 무슨 일을 할 지 커스터마이징하게끔 해줌
    - drop 메서드를 구현하야하며, 이 메서드는 self에 대한 가변 참조자를 매개변수로 갖음
- Drop 트레이트는 프렐루드에 포함되어 있으며 drop 메서드는 명시적으로 호출할 필요가 없이 스코프를 벗어나면 호출이 됨
- 변수들은 만들어진 순서의 역순으로 버려짐

### std::mem::drop으로 값을 일찍 버리기
- 러스트는 수동으로 Drop 트레이트의 drop 메서드를 호출하게 해주지 않는 대신, 표준 라이브러리가 제공하는 `std::mem::drop` 함수를 호출하여 스코프가 끝나기 전에 강제로 값을 버리도록 할 수 있음 
- `std::mem::drop` 함수는 Drop 트레이트에 있는 drop 메서드와는 다르며 프렐루드에 포함되어 있고, 일찍 버리려고 하는 값을 인수로 넘겨 호출함

## Rc<T>, 참조 카운트 스마트 포인터
