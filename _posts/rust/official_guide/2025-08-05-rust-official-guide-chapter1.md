---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 1장 요약"
description: CHAPTER 1 시작해봅시다
author: 김우석
date: 2025-08-05 08:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

## Rust 설치
- [Rust 공식 홈페이지](https://www.rust-lang.org/tools/install)


### 설치 확인
```bash
rustc --version
rustc 1.85.0 (4d91de4e4 2025-02-17) # output
```
- rustc x.y.z (abcabcabc yyyy-mm-dd)
    - 버전 : x.y.z
    - 커밋 해시 : abcabcabc
    - yy-mm-dd : 커밋 날짜


### Rust 업데이트 및 삭제
- 업데이트
    ```bash
    rustup update
    ```
- 삭제
    ```bash
    rustup self uninstall
    ```


### 로컬 문서
```bash
rustup doc
```


## 실습

### Hello, World!

#### 프로젝트 디렉터리 생성
```bash
mkdir ~/projects
cd ~/projects
mkdir hello_world
cd hello_world
```

#### 러스트 프로그램 작성 및 실행
1. main.rs 파일 생성 
2. Hello, world!를 출력하는 프로그램 작성
    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```
    - main 함수 : 러스트 실행 프로그램에서 항상 가정 먼저 실행되는 함수
    - 들여쓰기 : 스페이스 4칸을 사용
    - println! : 러스트의 매크로 호출 코드
        - 매크로는 함수와 항상 같은 규칙을 따르지는 않음
    - ';' : 현재 표현식이 끝났으며 다음 표현식이 시작될 준비가 됐다는 의미
3. 컴파일 및 실행
    ```bash
    rustc main.rs
    ```
4. 출력 확인
    ```bash
    ./main.exe
    Hello, world! # output
    ```


## 컴파일과 실행은 별개의 과정

### 컴파일
- rustc {소스 파일명}


### 컴파일 결과
- xx.exe
    - 실행 파일
- xx.pdb
    - 윈도우 환경에서만 생성이됨
    - Program Database의 약자로, 디버깅 정보를 담고 있는 파일


### 실행
- main.rs 를 빌드했다면, 빌드 결과인 main.exe를 실행
```bash
./main # 윈도우에서는 .\main.exe
```


## 카고 (Cargo)
러스트 빌드 시스템 및 패키지 매니저 도구

- 코드 빌드
- 외부 라이브러리 다운로드
- 라이브러리 제작
- ...


### 설치 확인
위 항목 의 `Rust 설치` 를 통해 설치를 진행했다면 카고가 함께 설치됨
```bash
$ cargo --version
cargo 1.85.0 (d73d2caf9 2024-12-31) # output
```


### 프로젝트 생성
- hello_cargo 프로젝트 생성
    ```bash
    cargo new hello_cargo
    # output
        Creating binary (application) `hello_cargo` package 
    note: see more `Cargo.toml` keys and their definittions at https://doc.rust-lang.org/cargo/referenc/e/manifest.html
    ```

    ```bash
    # cargo new 프로젝트명 을 통해 생성된 결과
    projects/
        |- hello_cargo/
            |- src/
                |- main.rs
            |- .gitignore
            |- Cargo.toml
    ```

    - 프로젝트 이름(hello_cargo)에 해당하는 디렉토리 생성
    - src/main.rs 와 Cargo.toml 생성
    - .gitignore 파일과 함께 Git 저장소가 초기화 (이미 Git 저장소가 있는 경우 Git 파일들은 생성되지 않음)
- 위와 같이 카고는 각각의 파일을 알맞은 위치에 배치하여 프로젝트를 조직화 하는 것을 도움


### TOML(Tom's Obvious, Minimal Language, https://toml.io)
`cargo new` 로 생성한 Cargo.toml 파일의 내용
```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

- [package] : 섹션 헤더로, Rust 패키지의 메타데이터를 정의
    - 프로젝트 이름, 버전, 설명, 라이선스 등
- [dependencies] : 프로젝트가 의존하는 외부 크레이트(라이브러리)를 명시
    - 러스트에서는 코드 패키지를 **크레이트(create)**라고 부름


### 카고를 통핸 프로젝트 빌드 및 실행

#### 빌드
```bash
cargo build
```


##### 결과
- 실행 파일 생성  
    - (cargo new 를 통해 생성한) 프로젝트 루트/target/debug/ 위치에 실행 파일을 생성
        - 기본 빌드가 디버그 빌드기 때문에, 카고는 debug라는 디렉터리에 바이너리를 생성
- 빌드의 결과로 생성된 Cargo.lock 파일은 프로젝트에서 사용하는 디펜던시의 정확한 버전을 자동으로 기록해두는 파일 (직접 수정할 필요 X)
    - 현재는 디펜던시를 가지지 않기 때문에 특별한 내용이 없음
    - Cargo.lock 파일의 내용
        ```lock
        # This file is automatically @generated by Cargo.
        # It is not intended for manual editing.
        version = 4

        [[package]]
        name = "hello_cargo"
        version = "0.1.0"
        ```


#### 실행 

##### `cargo build` 후 바이너리 파일 실행
```bash
./target/debug/hello_cargo # 윈도우에서는 .\target\debug\hello_cargo.exe
Hello, world! # output
```

##### 한 번에 프로젝트를 빌드하고 실행
```bash
cargo run
```
- 처음 빌드하는 프로젝트의 경우 (변경사항이 있는 경우)
    ```bash
    cargo run
    # output
    Compiling ttt v0.1.0 (C:\projects\rust_learn\ttt) # 빌드 수행
      Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.55s
        Running `target\debug\ttt.exe`
    Hello, world!
    ```
- 기존 빌드된 프로젝트의 경우 (변경사항이 없는 경우)
    ```bash
    cargo run
    # output
      Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
        Running `target\debug\hello_cargo.exe`
    Hello, world!
    ```
- 위와 같이 카고는 프로젝트의 파일 변경 사항이 있다면 다시 빌드를 수행하고, 변경사항이 없다면 기존 바이너리를 그대로 실행 (`Compiling ...` 를 하는지 하지 않는지의 차이)


#### 실행파일 생성 없이 컴파일 되는지만 확인
```bash
cargo check
```
- 소스가 문제 없이 컴파일 되는지만 빠르게 확인하는 명령어


##### 위 명령어가 필요한 이유?
- `cargo check`는 실행 파일을 생성하는 단계를 건너뛰기 때문에 cargo build보다 훨씬 빠름
- 코드를 작성하는 동안 프로젝트가 컴파일 되는지 지속적으로 검사하기 위함
- **주기적으로 `cargo check`를 실행해 코드에서 컴파일에 문제가 발생하지 않는지 확인하고, 실행 파일이 필요할 경우에만 `cargo build`를 사용**


### 릴리스 빌드 생성
```bash
cargo build --release
```
- 프로젝트를 완성하여 배포(릴리스)할 준비가 끝났다면 위 명령어를 사용하여 릴리스 빌드를 생성
    - 일반 빌드와의 차이점
        - target/debug 가 아닌 target/release에 실행파일이 생성
        - 컴파일 시 최적화를 진행하여 컴파일이 오래걸리는 대신 러스트 코드가 더 빠르게 작동
    - 일반 빌드시에는 최적화를 하지 않는 이유? (빌드가 두 종류로 나뉘게 된 이유)
        - 개발 중에는 빌드가 잦고 작업의 흐름을 끊지 않기 위해 빌드 속도가 빠를수록 좋음 (**일반 빌드**)
        - 배포용 프로그램은 잦은 빌드가 필요 없으며 빌드 속도보단 프로그램의 작동 속도가 더 중요 (**릴리스 빌드**)
            - 코드 작동 속도를 벤치마킹할 시에는 릴리스 빌드를 기준으로 하여야 함


-----

## 정리한 내용 이외의 중요한 내용
- Rust 는 기본적으로 **snake case** 를 기본으로 사용
- 들여쓰기는 기본적으로 스페이스 4칸을 사용
- Rust는 AOT(ahead-of-time) 컴파일 언어로 Rust 가 설치되지 않은 환경에서도 실행할 수 있음
    - AOT 컴파일이란?
        - 프로그램을 실행하기 전에 소스 코드를 기계어로 미리 번역하는 방식
- 운영체제에 상관 없이 같은 명령어를 사용한다는 것도 카고 사용으로 얻는 추가적인 장점

