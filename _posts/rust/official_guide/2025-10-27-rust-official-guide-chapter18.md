---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 18장 요약"
description: 패턴과 매칭
author: 김우석
date: 2025-10-27 21:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

## 패턴이 사용될 수 있는 모든 곳

### match 갈래
- match는 값을 여러 패턴에 대응(match) 시켜 각각의 경우에 맞는 코드를 실행하는 제어 흐름 표현식

### if let 조건 표현식
- if let은 단일 패턴과 값이 일치할 때만 코드를 실행하는 match의 축약형

### while let 조건 루프
- while let은 값이 특정 패턴과 계속 일치하는 동안 반복을 수행하는 루프

### for 루프
- for 루프의 왼쪽은단순한 변수명이 아니라 패턴으로 취급되어, 이터레이터가 반환하는 각 값을 그 패턴에 매칭해 내부 구성요소를 자동으로 분해하고 해당 부분들을 변수로 바인딩해 루프 본문에서 바로 사용

### let 구문
- let PATTERN = EXPRESSION; 와 같이 표현식을 패턴과 비교하여 찾은 이름을 할당함

### 함수 매개변수
- 함수 인자 자리에서도 패턴을 사용할 수 있어, 전달된 값을 함수 선언 시점에서 바로 구조 분해할 수 있음

## 반박 가능성: 패턴이 매칭에 실패할지의 여부
패턴의 두 가지 형태
- **반박 불가능한(irrefutable) 패턴** : 넘겨진 모든 가능한 값에 대해 매칭되는 패턴
- **반박 가능(refutable) 패턴** : 일부 가능한 값에 대해 매칭에 실패 할 수 있는 패턴
- `if let`과 `while let`은 패턴 매칭이 실패할 수도 있는 경우를 처리하기 위한 문법이므로, 반박 불가능한 패턴을 사용하면 컴파일러가 경고를 발생시킴
- `let`구문이나 함수 매개변수처럼 항상 값이 존재한다고 가정하는 문맥에서는 패턴이 반드시 반박 불가능해야 하며, 반박 가능한 패턴을 사용하려 하면 컴파일 오류가 발생

## 패턴이 유효한 모든 문법

### 리터럴 매칭
- 패턴과 리터럴을 직접 매칭시킬 수 있음
- 코드에서 특정한 구체적인 값을 가질 때 어떤 동작을 수행하려는 경우에 유용

### 명명된 변수 매칭
- 명명된 변수는 어떤 값과도 매칭되는 반박 불가능한 패턴
- match는 새로운 스코프를 시작하기 때문에, match 표현식 내부에서 패턴의 일부로서 선언된 변수는 모든 변수의 경우와 마찬가지로 match 구조 외부에 있는 같은 이름의 변수를 가리게 됨

### 다중 패턴
- match 표현식에서는 패턴에 대한 또는(`or`) 연산자인 `|` 문법을 사용하여 여러 패턴을 매칭시킬 수 있음
- match 문의 갈래에서 `1 | 2 => println!("one or tow")`와 같이 사용하며 갈래의 값 중 하나와 일치하면 해당 갈래의 코드가 실행됨

### ..=을 이용한 값의 범위 매칭
- `..=`문법은 경계 값을 포함하는 범위(range)와 매칭시키도록 해줌
- match 문의 갈래에서 `1 ..=5 => println!("one through five")` 와 같이 사용하며 1,2,3,4,5 중 하나라면 해당 갈래의 코드가 실행됨
- 컴파일러는 컴파일 타임에 범위가 비어 있지 않은지 확인하며, 러스트가 범위가 비어 있는지를 알 수 있는 유일한 타입은 char와 숫자이므로, 범위는 숫자 또는 char 값으로만 허용됨

### 값을 해체하여 분리하기

#### 구조체 해체하기
- 구조체의 각 필드를 별도의 변수로 분리해 사용할 수 있음
- 구조체 해체는 구조체 내부 데이터를 부분적으로 꺼내거나 특정 조건을 검사하기 위한 패턴 매칭 도구

#### 열거형 해체
- match 표현식에서 variant에 따라 내부 데이터를 분리하거나 조건적으로 처리할 수 있음
- 데이터가 없는 variant는 단순히 존재 여부로만 매칭되고, 구조체형 또는 튜플형 variant는 그 내부 값들을 해체할 수 있음

#### 중첩된 구조체와 열거형 해체하기
- 구조체 안에 열거형이 있거나, 열거형 안에 구조체가 있는 등 중첩된 형태도 해체할 수 있음

#### 구조체와 튜플 해체하기
- 구조체와 튜플이 섞여 있어도 패턴 조합을 통해 동시에 해체가 가능함

### 패턴에서 값 무시하기

#### _로 값 전체 무시하기
- 기존에 match 표현식의 마지막 갈래에서 밑줄을 모든 값과 일치하지만 값에 바인딩되지 않는 와일드 카드 패턴으로 사용했었는데 이는 함수 매개변수를 포함한 모든 패턴에 사용할 수도 있음

#### 중첩된 _로 값의 일부 무시하기
- 다른 패턴 내에서 `_`을 사용하여 값의 일부만 무시할 수도 있음
- 전체 구조는 매칭해야 하지만 특정 필드나 요소는 필요 없을 때 사용

#### _로 시작하는 이름으로 사용하지 않는 변수 무시하기
- 변수 이름을 밑줄로 시작하는 것으로 사용하지 않는 변수에 대해 경고하지 않도록 러스트에게 지시할 수 있음
- 프로토타이핑 중이거나 프로젝트를 막 시작할때와 같이, 아직 사용하지 않을 변수를 생성하는 것이 유용할 때도 있음

#### ..으로 값의 나머지 부분 무시하기
- `..` 패턴은 나머지 패턴에서 명시적으로 매칭시키지 않은 값의 모든 부분을 무시함
- `..` 문법을 사용하여 특정 부분만 사용하고 나머지는 무시할 수 있으므로 무시된 각 값에 밑줄을 나열할 필요가 없음
- `..` 이 어떤 값을 매칭시키고 어떤 값을 무시해야 하는지 불분명하다면, 러스트는 에러를 발생시킴

### 매치 가드를 사용한 추가 조건
- **매치 가드**는 match 갈래의 패턴 뒤에 지정되는 추가 if 조건으로, 해당 갈래가 선택되려면 이 조건도 매칭되어야 함
- 매치 가드에 OR 연산자 (`|`) 를 사용하여 여러 패턴을 지정할 수 있으며, 매치 가드 조건은 모든 패턴에 적용됨
- 매치 가드는 패턴만 가지고는 할 수 없는 더 복잡한 아이디어를 표현할 때 유용
- 단점으로는 매치 가드 표현식이 포함되면 컴파일러가 철저성(exhaustiveness)을 확인하려고 하지 않음

### @ 바인딩
- **at** 연산자 `@`을 사용하면 값에 대한 패턴 매칭 여부를 테스트하는 동시에 해당 값을 갖는 변수를 만들 수 있음


