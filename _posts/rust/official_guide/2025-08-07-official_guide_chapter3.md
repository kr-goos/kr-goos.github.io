---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 3장 요약"
description: CHAPTER 3 일반적인 프로그래밍 개념
author: 김우석
date: 2025-08-12 08:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

## 변수와 가변성
러스트는 **안정성과 쉬운 동시성을 활용하는 방식**으로 코드를 작성할 수 있도록 **변수는 기본적으로 불변(immutable)**
- 불변 변수 (Immutable Variable)
    - 한 번 값이 할당되면 **변경 불가**
    - 변수에 다시 값을 할당하려 하는 경우 **컴파일타임**에 에러가 발생
        - 에러메시지 : `cannot assign twice to immutable variable '변수명'`
- 가변 변수 (Mutable Variable)
    - **값 변경이 가능**한 변수
    - `mut` 키워드를 이용
    - **해당 변수의 값이 변할 것 이라는 의도를 전달**

| 구분 | 키워드 | 값 변경 가능 여부 |
| --- | --- | --- |
| 불변 변수 | `let`     | ❌ |
| 가변 변수 | `let mut` | ✅ |


### 상수
- 항상 불변 (가변 상수라는 개념은 없음)
- `let` 대신 `const` 키워드를 사용
- 값의 타입이 **반드시 명시** 되어야 함
- 전역 스코프를 포함한 어떤 스코프에서도 선언 가능 (코드의 많은 부분에서 알 필요가 잇는 값에 유용)
- **컴파일 타임**에 값이 확정 되어야 함 (런타임에서만 계산될 수 있는 결괏값은 안됨)
- 컴파일러는 컴파일 타임에 제한된 연산을 평가할 수 있음 ([상숫값 평가 참고](https://doc.rust-lang.org/reference/const_eval.html))
    - `const THREE_HHOURS_IN_SECONDS: u32 = 60 * 60 * 3;`
- 이름 짓는 관례로 상수는 단어 사이에 밑줄을 사용하고 모든 글자를 대문자로 사용


### 섀도잉
- 새 변수를 이전 변수명과 같은 이름으로 선언할 수 있음
- 첫 번째 변수가 두 번째 변수에 의해 **가려졌다(shadowed)** 고 표현
- 두번째 변수는 첫번째 것을 가려서, 스스로를 다시 가리거나 스코프가 끝날 때 까지 변수명의 사용을 가져감
- `let` 키워드를 통해 새로운 값을 만드는 것 (**`let`을 사용하지 않으면 컴파일 에러 발생**)
- `mut(가변 변수)`와 섀도잉의 차이
    - | 구분     | `mut` (가변 변수)            | 섀도잉 (Shadowing)                           |
      | ------ | ------------------------ | ----------------------------------------- |
      | 의미     | 같은 변수의 값을 변경             | 같은 이름의 **새 변수**를 선언하여 이전 변수를 가림           |
      | 메모리 주소 | **같음**                   | **다름** (새 변수는 새 메모리에 저장)                  |
      | 타입 변경  | ❌ 불가                     | ✅ 가능                                      |
      | 가변성 변경 | ❌ 불가 (처음 정한 `mut` 여부 고정) | ✅ 가능 (불변 ↔ 가변 자유롭게 변경 가능)                 |
      | 사용 목적  | 변수 값을 업데이트               | 변수의 의미를 단계별로 변경, 타입 변환, 불변성 유지하면서 값 변화 표현 |

## 데이터 타입
러스트의 모든 값은 특정한 **데이터 타입(data type)**을 가지며, 이는 러스트가 데이터로 작업하는 방법을 알 수 있도록 어떤 종류의 데이터가 지정되고 있는지 알려줌
- 러스트는 **정적 타입(statically typed)** 언어로, 모든 변수의 타입이 컴파일 시점에 반드시 정해져야 함
    - 컴파일러는 우리가 값을 어떻게 사용하는지에 따라 타입을 추측 할 수 있음
    - 여러 가지 타입이 가능하여 타입 추측이 안되는 경우 타입 명시를 추가해야 함

### 스칼라 타입
**스칼라(scalar)** 타입은 하나의 값을 표현

<!-- | 스칼라 타입 |설명|
| --- | --- |
| **정수 타입**    | 부호 있는/없는 정수 (`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`) |
| **부동소수점 타입** | 실수(`f32`, `f64`)                                                                                     |
| **불리언 타입**   | 참/거짓(`bool`)                                                                                         |
| **문자 타입**    | 유니코드 스칼라 값 하나(`char`)                                                                                | -->

#### 정수형
**정수형(integer)**은 소수점이 없는 숫자이며 부호 있는(signed) 또는 부호 없는(unsigned) 타입이며 명시된 크기를 가짐

| 길이 | 부호 있음(signed) | 부호 없음(unsigned) |
|---|:---:|:---:|
|8-bit|i8|u8|
|16-bit|i16|u16|
|32-bit|i32|u32|
|64-bit|i64|u64|
|128-bit|i128|u128|
|arch|isize|usize|

- 부호 있는 정수(2의 보수 형태를 사용)
    - 범위 = `-2^(n-1)` ~ `2^(n-1) - 1`
- 부호 없는 정수
    - 범위 = `0` ~ `2^n - 1`
- `isize`와 `usize` 타입은 프로그램이 작동하는 컴퓨터 환경에 따라 결정
    - 64-bit 아키텍처이면 64비트
    - 32-bit 아키텍처이면 32비트
    - 주로 어떤 컬렉션 종류의 인덱스에 사용됨
- 러스트의 정수형 리터럴
    - | 숫자 리터럴 | 예 |
      |---|---|
      |10진|98_222|
      |16진|0xff|
      |8진|0o77|
      |2진|0b1111_0000|
      |바이트(u8)|b'A'|
      |타입 접미사|10i32|
      |밑줄 사용|10_000_000|