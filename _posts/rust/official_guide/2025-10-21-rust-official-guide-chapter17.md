---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 17장 요약"
description: 러스트의 객체 지향 프로그래밍 기능
author: 김우석
date: 2025-10-21 08:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

## 객체 지향 언어의 특성

### 객체는 데이터와 동작을 담습니다
- 러스트의 구조체와 열거형이 객체라고 호칭되지는 않더라도 데이터가 있고, impl 블록은 그 구조체와 열거형에 대한 메서드를 제공하기 때문에 러스트는 객체 지향적 이라 볼 수 있음

### 상세 구현을 은닉하는 캡슐화
- OOP와 연관된 또 다른 측면은 **캡슐화(encapsulation)** 개념으로, 객체를 이용하는 코드에서 그 객체의 상세 구현에 접근할 수 없게 하고 공개 API 를 통해서만 객체와 상호작용할 수 있도록 함
- 코드의 서로 다른 부분들에 대해 pub을 사용할지 여부를 선택하는 옵션을 통해 구현 세부사항을 캡슐화 할 수 있으므로, 캡슐화가 객체 지향 언어로 간주하기 위해 필요한 측면이라면, 러스트는 해당 요구 사항을 충족함

### 타입 시스템과 코드 공유로서의 상속
- **상속(inheritance)**은 어떤 객체가 다른 객체의 정의로부터 요소를 상속받을 수 있는 메커니즘으로, 이를 통해 객체를 다시 정의하지 않고도 부모 객체의 데이터와 동작을 가져올 수 있음
- 만약 객체 지향 언어가 반드시 상속을 제공해야 한다면, 러스트는 매크로를 사용하지 않고 부모 구조체의 필드와 메서드 구현을 상속받는 구조체를 정의할 방법이 없음
- 상속의 주요 목적 중 하나는 **코드 재사용** (기존 구현을 다른 타입에 활용)
    - 러스트에서는 상속 대신 트레잇의 기본 메서드 구현을 사용하여 코드를 재사용 할 수 있음
    - 트레잇을 구현한 타입은 트레잇이 제공하는 기본 메서드 구현을 그대로 사용할 수도 있고, 필요하면 그 메서드를 오버라이딩 하여 새로 정의할 수도 있음
- 상속의 주요 목적 중 또 다른 하나는 **다형성(polymorphism)** (부모 타입 자리에 자식 타입을 넣어도 동작)
    - 러스트는 대신 제네릭을 사용하여 호환 가능한 타입을 추상화하고 트레이트 바운드를 이용하여 해당 타입들이 반드시 제공해야하는 제약을 부과하는데 이를 **범주 내 매개변수형 다형성** 라 부름

