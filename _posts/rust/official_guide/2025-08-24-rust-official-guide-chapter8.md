---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 8장 요약"
description: CHAPTER 8 일반적인 컬렉션
author: 김우석
date: 2025-08-28 07:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

- 컬렉션 : 여러 값을 한 데이터 구조에 담아 다룰 수 있는 표준 라이브러리 타입들의 모음
    - 벡터 : 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해줌
    - 문자열 : 문자의 모음
    - 해시 맵 : 어떤 값을 특정한 키와 연관지어주도록 해줌

## 벡터에 여러 값의 목록 저장하기
- 벡터 타입 : `Vec<T>`
    - 메모리에서 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조
    - 하나 이상의 값을 저장할 수 있음
    - 같은 타입의 값만 저장할 수 있음
        - 여러 타입을 섞어 쓰고 싶은 경우 `enum` 또는 `박스` 같은 트릭을 사용해야 한다고 함

### 새 벡터 만들기
```rust
let v: Vec<i32> = Vec::new()
```

- 비어 있는 새 벡터를 만들려면 `Vec::new` 함수를 호출
- 벡터는 제네릭을 이용하여 구현됨
    - **제네릭**이란 타입을 매개변수처럼 받아 여러 타입에 대해 재사용할 수 있게 해주는 기능을 말함
        - 위 에서 지정한 `<i32>` 는 `Vec`가 `i32` 타입의 요소를 갖음을 러스트에게 알려주는 것
        - 제네릭에 지정한 타입에 따라 어떠한 타입의 값이라도 저장할 수 있음
- **초깃값이 없는 벡터를 생성 경우** 
    - 저장하고자 하는 요소가 어떤 타입인지 알지 못하므로 **타입 명시가 필요**
- **초깃값이 있는 벡터를 생성 경우**
    - 저장하고자 하는 값의 타입을 대부분 유추할 수 있으므로 **타입 명시가 거의 불필요**
        - 초깃값이 있지만 값의 타입이 유추가 안되는 경우 초깃값이 없는 벡터와 같이 **타입 명시가 필요**
- `vec!` 매크로를 제공
    - 제공된 값들을 저장한 새로운 `Vec`를 생성
    - ```rust
      let v = vec![1,2,3];
      ```
        - 러스트는 벡터에 지정된 값을 보고 타입을 추론할 수 있으므로 타입 명시는 필요 없음
            - 기본 정수형이 `i32` 이기 때문에 위 변수의 타입은 `Vec<i32>`


### 벡터 업데이트하기
```rust
let mut v = Vec::new();
v.push(5);
v.push(6);
```

- `push` 메서드를 사용하여 벡터에 요소를 추가
- 벡터의 값을 변경하려면 가변 변수로 만들어야 함
- `Vec<i32>` 타입을 명시하지 않아도 되는 이유
    - 집어 넣은 숫자가 모두 `i32` 타입인 점을 통해 러스트가 `v` 의 타입을 추론


### 벡터 요소 읽기
```rust
let v = vec![1,2,3,4,5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

- 벡터에 저장된 값을 참조하는 방법
    - 인덱싱 (`v[i]`)
        - 벡터에서 `i` 번째 요소를 **직접 반환**
        - 인덱스 범위를 벗어나면 **panic 발생** 
            - ```bash
              thread 'main' panicked at main.rs:4:28:
              index out of bounds: the len is 5 but the index is 100
              note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
              ```
    - `get` 메서드 (`v.get(i)`)
        - 벡터에서 `i` 번째 요소를 **`Option<&T>`로 반환**
        - 인덱스 범위를 벗어나면 `None`
- 벡터 요소를 참조하는 방법을 두 가지 제공하는 이유
    - 벡터에 없는 인덱스값을 사용하고자 했을 때 프로그램이 어떻게 작동할 것인지 선택할 수 있도록 하기 위함
- 유효한 참조자를 얻을 때, 빌림검사기가 소유권 및 빌림 규칙을 집행
    - 빌림검사기 
        - 컴파일 시점에 소유권(ownership)과 빌림(borrowing) 규칙을 검사하는 컴파일러 내부 기능
        - 즉, 누가 어떤 값을 읽고 쓰는지, 언제 값이 해제되는지를 체크해서 런타임 오류 없이 안전하게 참조할 수 있는지를 보장
    - ```rust
      let mut v = vec![1, 2, 3, 4, 5];

      let first = &v[0]; // 불변 참조

      v.push(6); // 재할당 발생 가능
      ```
        - 댕글링 참조 발생으로 컴파일 에러가 발생
            - `error[E0502]: cannot borrow 'v' as mutable because it is also borrowed as immutable`
                - 즉, **빌림검사기가 "first 참조자가 아직 살아있는데 push 같은 변경을 하면 위험하다"**라고 판단해서 차단
            - 벡터는 연속된 메모리 블록을 사용
            - 새로운 요소를 `push` 할 때 남은 공간이 부족한 경우 (len == cap)
                - 더 큰 메모리 블록을 새로 할당
                - 기존 요소들을 새 메모리로 복사
                - 예전 메모리는 해제
                - 새 메모리에 새 요소 추가
            - 기존 요소에 대한 참조자 `first`는 이미 해제 된 옛 메모리를 가리키게 됨
            - 만약 `len < cap` 인 경우 (재할당이 일어나지 않는 경우) 에러가 발생하지 않을까?
                - 빌림 검사기는 "재할당이 실제로 일어나는지"는 알지 못함
                - 즉, Vec의 내부 capacity 상태를 보지 않고, 단순히 **"push가 메모리를 이동시킬 수 있는 가능성이 있다"**는 이유로 불변 참조(`&v[0]`)와 가변 빌림(`v.push`)을 동시에 허용하지 않음을 규칙으로 강제
    
### 벡터값에 대해 반복하기

- for 루프로 벡터의 요소들에 대해 반복하여 각 요소를 출력

```rust
let v = vec![100, 32 ,57];
for i in &v {
    println!("{i}");
}
```

- 벡터 요소에 대한 가변 참조로 반복

```rust
let mut v = vec![100, 32 ,57];
for i in &mut v {
    *i += 50;
}
```

- 가변 참조자가 가리키는 값을 수정
    - `for i in &mut v`
        - 루프 안에서 `i`는 벡터 내부 요소의 가변 참조 (`&mut i32`) 를 받게 됨
    - `*i`를 사용해야 하는 이유?
        - `i` 자체는 **가변 참조(`&mut i32`)**라서, 그냥 `i += 50` 을 하면 "참조 자체에 더하기" 를 하는 의미가 되어 컴파일 에러가 발생
        - 역참조를 해서 `i32` 값을 꺼냄

```text
벡터에 대한 반복 처리는 불변이든 가변이든 상관없이 대여 검사 규칙에 의해 안전합니다.
```

### 열거형을 이용해 여러 타입 저장하기

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
]
```

- 열거형의 배리언트는 같은 열거형 타입에 정의되므로 열거형을 담을 벡터를 생성하여 사용
    - 다양한 타입의 값을 갖는 배리언트를 보유한 열거형을 정의
    - 모든 열거형 배리언트들은 해당 열거형 타입과 같은 타입으로 간주
- 러스트가 컴파일 타임에 벡터 내에 저장될 타입이 무엇인지 알아야 하는 이유
    - 타입을 알아야 각 요소가 차지하는 크기 를 알 수 있기 때문
    - 각 요소를 저장하기 위해 얼마만큼의 힙 메모리가 필요한지 알아야 하기 때문 
        - 만약 크기를 모른다면, 벡터가 메모리를 얼마나 잡아야 할지 몰라서 안전하게 요소를 저장할 수 없음

### 벡터가 버려지면 벡터의 요소도 버려집니다

```rust
{
    let v = vec![1, 2, 3, 4];
    // v 를 가지고 작업하기
} // <- 여기서 v 가 스코프 밖으로 벗어나고 해제됩니다.
```

- `struct` 와 마찬가지로 벡터는 스코프를 벗어날 때 해제됨
- 벡터가 버려질 때 벡터의 내용물도 전부 버려짐 (벡터가 가지고 있던 메모리가 정리됨)
- 대여 검사기는 벡터의 내용물에 대한 참조자의 사용이 해당 벡터가 유효할 때만 발생했는지 확인


## 문자열에 UTF-8 텍스트 저장하기