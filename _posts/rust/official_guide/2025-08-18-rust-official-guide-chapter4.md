---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 4장 요약"
description: CHAPTER 4 소유권 이해하기
author: 김우석
date: 2025-08-18 08:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

소유권은 러스트가 가비지 컬렉터 없이 메모리 안정성을 보장하도록 해주므로, 소유권이 어떻게 작동하는지를 이해하는 것이 중요합니다.

## 소유권이 뭔가요?
**소유권(ownership)** 은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음입니다. 모든 프로그램은 작동하는 동안 컴퓨터의 메모리 사용 방법을 관리해야 합니다.
러스트에서는 소유권 이라는 시스템을 이용하여 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식사용하고, 이 규칙 중 하나라도 위반하면 프로그램은 컴파일 되지 않습니다.

### 소유권 규칙
- 러스트에서, 각각의 값은 **소유자(owner)**가 정해져 있습니다.
- 한 값의 소유자는 동시에 여럿 존재할 수 없습니다.
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려집니다(dropped).

### 변수의 스코프
스코프란, 프로그램 내에서 아이템이 **유효한 범위** 를 말합니다.

```rust
{                       // s는 아직 선언되지 않아서 유효하지 않음
    let s = "hello";    // 이 지점부터 s 가 유효
    ...                 // s 유효
}                       // 스코프 종료로, s가 더이상 유효하지 않음
```
- s가 스코프 내에 나타나면 유효합니다.
- 유효 기간(생명주기)은 스코프 밖으로 벗어나기 전까지입니다.


### 메모리와 할당
문자열 리터럴은 컴파일 타임에 내용을 알 수 있어 텍스트가 최종 실행 파일에 하드코딩 됩니다. 이 방식은 빠르고 효율적이지만, 문자열이 변하지 않을 경우에만 사용할 수 있습니다. 반면, String 타입은 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있습니다. 이는 다음을 의미하기도 합니다.

- 실행 중 메모리 할당자로부터 메모리를 요청해야 합니다.
- String 사용을 마쳤을 때 메모리를 해제할(즉, 할당자에게 메모리를 반납할) 방법이 필요합니다.

이 중 첫 번째는 `String::from` 호출로, 필요한 메모리를 요청하도록 구현되어있습니다.
두 번 째는, **가비지 컬렉터(garbage collector, GC)** 를 갖는 언어에서는 GC가 사용하지 않는 메모리를 찾아 없애주지만, GC가 없는 언어에서는 할당받은 **메모리가 필요 없어지는 지점을 프로그래머가 직접 찾아 메모리 해제 코드를 작성**해야합니다. 이는 아래와 같은 문제들을 야기할 수 있습니다.

- 프로그래머가 놓친 부분이 있다면 메모리 낭비가 발생함
- 메모리 해제 시점을 너무 일찍 잡으면 유효하지 않은 변수가 생김
- 두 번 해제할 경우도 마찬가지로 버그가 발생

러스트는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결

```rust
{
    let s = String::from("hello"); // s는 이 지점부터 유효
                                   // s 를 가지고 무언가를 함
}                                  // 스코프가 종료되었고, s는 더이상 유효하지 않음
```

- `s`가 스코프 밖으로 벗어나면, `String` 에서 사용한 메모리를 자연스럽게 해제합니다.
    - 러스트는 변수가 스코프 밖으로 벗어나면 `drop` 이라는 특별한 함수를 호출합니다. (즉, 닫힌 중괄호(`}`)가 나타나는 지점에서 자동으로 호출)
    - `drop`은 해당 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있게 되어있습니다.


#### 변수와 데이터 간 상호작용 방식:이동

**Copy(복사)**
```rust
let x = 5;
let y = x;
```
- 값이 **스택(stack)**에 바로 저장되는 단순한 타입들은 그냥 값을 복사해서 새 변수에 바인딩합니다.
    - `5`를 `x`에 바인딩하세요.
    - `x`값의 복사본을 만들어 `y`에 바인딩하세요.
    - 따라서 두 `5`값은 스택에 푸시됩니다.

**Move(이동)**
```rust
let s1 = String::from("hello");
let s2 = s1;
```
- 값이 **힙(heap)**에 있는 데이터를 가리키는 타입들은 새 변수에 대입하면 데이터를 **복사하지 않고**, 원래 변수가 가지고 있던 **소유권**을 그대로 넘겨줍니다.
- `let s1 = String::from("hello");`
    - 스택(stack)
        - s1
            |이름|값|
            |-|-|
            |포인터|힙에 저장된 "hello" 문자열 데이터의 시작 주소|
            |길이|5|
            |용량|5|
    - 힙(Heap)
        - |인덱스|값|
          |-|-|
          |0|h|
          |1|e|
          |2|l|
          |3|l|
          |4|o|
- `let s2 = s1;`
    - `s2` 에 `s1` 을 대입하면 String 데이터(Stack 의 값)가 복사됩니다.
        - s2
            |이름|값|
            |-|-|
            |포인터|힙에 저장된 "hello" 문자열 데이터의 시작 주소|
            |길이|5|
            |용량|5|
    - Rust 는 **소유권(ownership)**을 `s1`에서 `s2`로 **이동**시킵니다.
        - `s1` 은 더이상 사용할 수 없게 됩니다. (유효하지 않은 참조자의 사용을 감지했다는 에러 발생)
            - 만약 `s1`와 `s2` 의 포인터가 모두 같은 Heap 을 바라보고 있다면 `s1`, `s2`가 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 **중복해제(double free)** 에러가 발생할 것입니다.따라서 러스트는 **메모리 안정성을 보장**하기 위해 let s2 = s1; 라인 뒤로는 더이상 s1이 **유효하지 않다고 판단**합니다.
    - 위 과정을 거쳐 `s1`이 `s2`로 **이동되었다** 라고 표현합니다.
    - ![rust-string](../../../assets/img/posts/rust/official-guide/chapter4/rust_string.png)


#### 변수와 데이터 간 상호작용 방식:클론
String의 힙 데이터까지 깊이 복사하고 싶을 경우 `clone` 이라는 공용 메서드를 사용할 수 있습니다. `clone` 은 **깊은 복사(Deep Copy)** 를 수행하여 힙 데이터까지 복사하는 동작을 수행합니다.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

#### 스택에만 저장되는 데이터:복사
정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문에, 복사본을 빠르게 만들 수 있고, 따라서 굳이 새 변수를 사용할 때 기존 변수를 무효화 할 필요가 없습니다. 즉, 깊은 복사와 얕은 복사 간에 차이가 없습니다.

- Copy 가능한 타입
    - 모든 정수형 타입
    - true, false값을 갖는 논리 자료형 bool
    - 모든 부동소수점 타입
    - 문자 타입 char
    - Copy 가능한 타입만으로 구성된 튜플(예를들어, (i32,i32)는 Copy 가능하지만 (i32, String)은 불가능)

### 소유권과 함수

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다.

    takes_ownership(s);             // s의 값이 함수로 이동됩니다.
                                    // 따라서 여기서는 더이상 유효하지 않습니다.

    let x = 5;                      // x가 스코프 안으로 들어옵니다.

    makes_copy(x);                  // x가 함수로 이동됩니다. 하지만,
                                    // i32는 Copy이므로 앞으로 계속 x를 사용해도 좋습니다.
}   // 여기서 x가 스코프 밖으로 벗어나고 s도 그렇게 됩니다. 그러나 s의 값이 이동되었으므로
    // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) {   // some_string이 스코프 안으로 들어옵니다.
    println!("{}",some_string);
}   // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됩니다.
    // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) {          // some_integer가 스코프 안으로 들어옵니다.
    println!("{}",some_integer);
}   // 여기서 some_integer가 스코프 밖으로 벗어납니다. 별다른 일이 발생하지 않습니다.
```
- `takes_ownership`함수를 호출한 이후 `s`를 사용하려 할 경우, 컴파일 타임 에러가 발생됩니다.
    - 이와같이 변수 사용하는 코드를 여기 저기 집어 넣어, 어느 지점에서 변수를 사용할 수 있고 어느 지점에서 소유권 규칙이 제재하는지 확인해볼 수 있다.


### 반환값과 스코프

```rust
fn main() {
    let s1 = gives_ownership();                 // gives_ownership이 자신의 반환값을 s1로 이동시킵니다

    let s2 = String::from("hello");             // s2가 스코프 안으로 들어옵니다.

    let s3 = takes_and_gives_back(s2);          // s2는 takes_and_gives_back으로 이동되는데,
                                                // 이 함수 또한 자신의 반환값을 s3으로 이동시킵니다.
}   // 여기서 s3가 스코프 밖으로 벗어나면서 버려집니다. s2는 이동되어서 아무 일도 일어나지 않습니다.
    // s1은 스코프 밖으로 벗어나고 버려집니다.

fn gives_ownership() -> String {                // gives_ownership은 자신의 반환값을 
                                                // 자신의 호출자 함수로 이동시킬 것입니다.

    let some_string = String::from("yours");    // some_string이 스코프 안으로 들어옵니다.

    some_string                                 // some_string이 반환되고, 호출자 함수 쪽으로 이동합니다.

}


fn takes_and_gives_back(a_string: String) -> String {   // a_string이 스코프 안으로 들어옵니다.
    a_string // a_string 이 반환되고 호출자 함수 쪽으로 이동합니다.
}
```

- 상황은 다양할지라도, 변수의 소유권 규칙은 언제나 동일합니다.
    - 어떤 값을 다른 변수에 대입하면 값이 이동하고, 힙에 데이터를 갖는 변수가 스코프를 벗어나면, 사전에 해당 데이터가 이동하여 소유권이 다른 변수에 이동되지 않은 이상 drop에 의해 데이터가 제거됩니다.
