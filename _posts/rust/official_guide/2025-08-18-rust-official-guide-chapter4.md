---
title: "[RUST] 러스트 프로그래밍 공식 가이드(제2판) 4장 요약"
description: CHAPTER 4 소유권 이해하기
author: 김우석
date: 2025-08-18 08:00:00 +0900
categories: [Rust, OfficialGuide]
tags: [Rust]
image:
  path: /assets/img/posts/rust/rust-logo.svg
---

소유권은 러스트가 가비지 컬렉터 없이 메모리 안정성을 보장하도록 해주므로, 소유권이 어떻게 작동하는지를 이해하는 것이 중요합니다.

## 소유권이 뭔가요?
**소유권(ownership)** 은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음입니다. 모든 프로그램은 작동하는 동안 컴퓨터의 메모리 사용 방법을 관리해야 합니다.
러스트에서는 소유권 이라는 시스템을 이용하여 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식사용하고, 이 규칙 중 하나라도 위반하면 프로그램은 컴파일 되지 않습니다.

### 소유권 규칙
- 러스트에서, 각각의 값은 **소유자(owner)**가 정해져 있습니다.
- 한 값의 소유자는 동시에 여럿 존재할 수 없습니다.
- 소유자가 스코프 밖으로 벗어날 때, 값은 버려집니다(dropped).

### 변수의 스코프
스코프란, 프로그램 내에서 아이템이 **유효한 범위** 를 말합니다.

```rust
{                       // s는 아직 선언되지 않아서 유효하지 않음
    let s = "hello";    // 이 지점부터 s 가 유효
    ...                 // s 유효
}                       // 스코프 종료로, s가 더이상 유효하지 않음
```
- s가 스코프 내에 나타나면 유효합니다.
- 유효 기간(생명주기)은 스코프 밖으로 벗어나기 전까지입니다.

### String 타입



### 메모리와 할당
문자열 리터럴은 컴파일 타임에 내용을 알 수 있어 텍스트가 최종 실행 파일에 하드코딩 됩니다. 이 방식은 빠르고 효율적이지만, 문자열이 변하지 않을 경우에만 사용할 수 있습니다. 반면, String 타입은 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있습니다. 이는 다음을 의미하기도 합니다.

- 실행 중 메모리 할당자로부터 메모리를 요청해야 합니다.
- String 사용을 마쳤을 때 메모리를 해제할(즉, 할당자에게 메모리를 반납할) 방법이 필요합니다.

이 중 첫 번째는 `String::from` 호출로, 필요한 메모리를 요청하도록 구현되어있습니다.
두 번 째는, **가비지 컬렉터(garbage collector, GC)** 를 갖는 언어에서는 GC가 사용하지 않는 메모리를 찾아 없애주지만, GC가 없는 언어에서는 할당받은 **메모리가 필요 없어지는 지점을 프로그래머가 직접 찾아 메모리 해제 코드를 작성**해야합니다. 이는 아래와 같은 문제들을 야기할 수 있습니다.

- 프로그래머가 놓친 부분이 있다면 메모리 낭비가 발생함
- 메모리 해제 시점을 너무 일찍 잡으면 유효하지 않은 변수가 생김
- 두 번 해제할 경우도 마찬가지로 버그가 발생

러스트는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결

```rust
{
    let s = String::from("hello"); // s는 이 지점부터 유효
                                   // s 를 가지고 무언가를 함
}                                  // 스코프가 종료되었고, s는 더이상 유효하지 않음
```

- `s`가 스코프 밖으로 벗어나면, `String` 에서 사용한 메모리를 자연스럽게 해제합니다.
    - 러스트는 변수가 스코프 밖으로 벗어나면 `drop` 이라는 특별한 함수를 호출합니다. (즉, 닫힌 중괄호(`}`)가 나타나는 지점에서 자동으로 호출)
    - `drop`은 해당 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있게 되어있습니다.

#### 변수와 데이터 간 상호작용 방식: 이동
